import Foundation
import PromiseKit

public class VerifiableCredential: DIDObject {
    private var _types: Array<String> = []
    private var _issuer: DID?
    private var _issuanceDate: Date?
    private var _expirationDate: Date?
    private var _subject: VerifiableCredentialSubject?
    private var _proof: VerifiableCredentialProof?
    private var _meta: CredentialMeta?

    private let RULE_EXPIRE : Int = 1
    private let RULE_GENUINE: Int = 2
    private let RULE_VALID  : Int = 3

    private var meta: CredentialMeta?

    override init() {
        super.init()
    }

    init(_ credential: VerifiableCredential) {
        super.init(credential.getId(), credential.getType())

        self._types = credential.getTypes()
        self._issuer = credential.issuer
        self._issuanceDate = credential.issuanceDate
        self._expirationDate = credential.expirationDate
        self._subject = credential.subject
        self._proof = credential.proof
    }

    override func setId(_ id: DIDURL) {
        super.setId(id)
    }

    /// Get the type of string type
    /// - Returns: the credential types, which declare what data to expect in the credential
    public override func getType() -> String {
        var builder = ""
        var first = true

        builder.append("[")
        for type in _types {
            builder.append(!first ? ", ": "")
            builder.append(type)

            if  first {
                first = true
            }
        }
        builder.append("]")

        return builder
    }

    /// Get the type of array type
    /// - Returns: the credential types, which declare what data to expect in the credential
    public func getTypes() -> [String] {
        return self._types
    }

    func appendType(_ type: String) {
        self._types.append(type)
    }

    func setType(_ newTypes: [String]) {
        for type in newTypes {
            self._types.append(type)
        }
    }

    /// the entity that issued the credential
    public var issuer: DID {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return self._issuer!
    }

    // This type of getXXXX function would specifically be provided for
    // sdk internal when we can't be sure about it's validity/integrity.
    func getIssuer() -> DID? {
        return self._issuer
    }

    func setIssuer(_ newIssuer: DID) {
        self._issuer = newIssuer
    }

    /// when the credential was issued
    public var issuanceDate: Date {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return _issuanceDate!
    }

    func getIssuanceDate() -> Date? {
        return _issuanceDate
    }

    func setIssuanceDate(_ issuanceDate: Date) {
        self._issuanceDate = issuanceDate
    }

    /// when the credential will expire
    public var expirationDate: Date {
        // Guaranteed that this field would not be nil because the object
        // was generated by "builder".
        return _expirationDate!
    }

    func getExpirationDate() -> Date? {
        return _expirationDate
    }

    func setExpirationDate(_ expirationDate: Date) {
        self._expirationDate = expirationDate
    }

    func getMeta() -> CredentialMeta {
        if  self._meta == nil {
            self._meta = CredentialMeta()
        }
        return self._meta!
    }

    func setMeta(_ newValue: CredentialMeta) {
        self._meta = newValue
    }

    /// claims about the subject of the credential
    /// - Parameters:
    ///   - value: Cedential subject value
    ///   - forName: Key of credential subject
    /// - Throws: Throws error when the key is empty or the storage fails
    public func setExtra(value: String, forName: String) throws {
        guard !forName.isEmpty else {
            throw DIDError.illegalArgument("extra name is empty")
        }

        getMeta().setExtra(value, forName)
        try getMeta().store?.storeCredentialMeta(for: subject.did, key: getId(), meta: getMeta())
    }

    /// Get credential subject value
    /// - Parameter forName: Key of credential subject
    /// - Returns: Cedential subject valueï¼ŒCan be nil
    public func getExtra(forName: String) -> String? {
        return getMeta().getExtra(forName)
    }
    
    /// <#Description#>
    public var aliasName: String {
        return getMeta().aliasName
    }

    private func setAliasName(_ newValue: String?) throws {
        getMeta().setAlias(newValue)
        try getMeta().store?.storeCredentialMeta(for: subject.did, key: getId(), meta: getMeta())
    }

    /// <#Description#>
    /// - Throws: <#description#>
    public func unsetAlias() throws {
        try setAliasName(nil)
    }

    /// <#Description#>
    /// - Parameter newValue: <#newValue description#>
    /// - Throws: <#description#>
    public func setAlias(_ newValue: String) throws {
        try setAliasName(newValue)
    }
    
    /// <#Description#>
    /// - Returns: <#description#>
    public func isSelfProclaimed() -> Bool {
        return issuer == subject.did
    }
    
    private func traceCheck(_ rule: Int) throws -> Bool {
        var controllerDoc: DIDDocument?
        do {
            controllerDoc = try issuer.resolve()
        } catch {
            controllerDoc = nil
        }

        guard let _ = controllerDoc else {
            return false
        }

        switch rule {
        case RULE_EXPIRE:
            if controllerDoc!.isExpired {
                return true
            }
        case RULE_GENUINE:
            if !controllerDoc!.isGenuine {
                return false
            }
        case RULE_VALID:
            if !controllerDoc!.isValid {
                return false
            }
        default:
            break
        }

        if !isSelfProclaimed() {
            let issuerDoc: DIDDocument?
            do {
                issuerDoc = try issuer.resolve()
            } catch {
                issuerDoc = nil
            }
            guard let _ = issuerDoc else {
                return false
            }

            switch rule {
            case RULE_EXPIRE:
                if issuerDoc!.isExpired {
                    return true
                }
            case RULE_GENUINE:
                if !issuerDoc!.isGenuine {
                    return false
                }
            case RULE_VALID:
                if !issuerDoc!.isValid {
                    return false
                }
            default:
                break
            }
        }

        return rule != RULE_EXPIRE
    }
    
    private func checkExpired() throws -> Bool {
        return _expirationDate != nil ? DateHelper.isExipired(_expirationDate!) : false
    }

    /// Returns true when the credential expires
    public var isExpired: Bool {
        do {
            return try traceCheck(RULE_EXPIRE) ? true : checkExpired()
        } catch {
            return false
        }
    }

    /// Is credential expired
    /// - Returns: Returns true asynchronous when the credential expires
    public func isExpiredAsync() -> Promise<Bool> {
        return Promise<Bool> { $0.fulfill(isExpired) }
    }

    private func checkGenuine() throws -> Bool {
        let doc = try issuer.resolve()

        // Credential should signed by authentication key.
        guard doc.containsAuthenticationKey(forId: proof.verificationMethod) else {
            return false
        }
        // Unsupported public key type;
        guard proof.type == Constants.DEFAULT_PUBLICKEY_TYPE else {
            return false
        }

        guard let data = toJson(true, true).data(using: .utf8) else {
            throw DIDError.illegalArgument("credential is nil")
        }
        return try doc.verify(proof.verificationMethod, proof.signature, [data])
    }

    /// Verify that the credential data is original
    public var isGenuine: Bool {
        do {
            if try !traceCheck(RULE_GENUINE) {
                return false
            }
            return try checkGenuine()
        } catch {
            return false
        }
    }

    /// Asynchronously verify that the credential data is original
    /// - Returns: Returns true when the credential data is the original
    public func isGenuineAsync() -> Promise<Bool> {
        return Promise<Bool> { $0.fulfill(isGenuine) }
    }

    /// whether credential is available
    public var isValid: Bool {
        do {
            if try !traceCheck(RULE_VALID) {
                return false
            }
            return try !checkExpired() && checkGenuine()
        } catch {
            return false
        }
    }

    /// Asynchronously determine whether credentral is available
    /// - Returns: Returns true when credentral is available
    public func isValidAsync() -> Promise<Bool> {
        return Promise<Bool> { $0.fulfill(isValid) }
    }

    /// claims about the subject of the credential
    public var subject: VerifiableCredentialSubject {
        return _subject!
    }

    func getSubject() -> VerifiableCredentialSubject? {
        return _subject
    }

    func setSubject(_ newSubject: VerifiableCredentialSubject) {
        self._subject = newSubject
    }

    /// digital proof that makes the credential tamper-evident
    public var proof: VerifiableCredentialProof {
        return _proof!
    }

    func getProof() -> VerifiableCredentialProof? {
        return _proof
    }

    func setProof(_ newProof: VerifiableCredentialProof) {
        self._proof = newProof
    }

    func checkIntegrity() -> Bool {
        return (!getTypes().isEmpty && _subject != nil)
    }

    func parse(_ node: JsonNode, _ ref: DID?) throws  {
        let error = { (des) -> DIDError in
            return DIDError.malformedCredential(des)
        }

        let serializer = JsonSerializer(node)
        var options: JsonSerializer.Options

        let arrayNode = node.get(forKey: Constants.TYPE)?.asArray()
        guard let _ = arrayNode else {
            throw DIDError.malformedCredential("missing credential type")
        }
        for item in arrayNode! {
            appendType(item.toString())
        }

        options = JsonSerializer.Options()
            .withHint("credential expirationDate")
            .withError(error)
        let expirationDate = try serializer.getDate(Constants.EXPIRATION_DATE, options)

        options = JsonSerializer.Options()
            .withRef(ref)
            .withHint("credential id")
            .withError(error)
        let id = try serializer.getDIDURL(Constants.ID, options)

        var subNode = node.get(forKey: Constants.CREDENTIAL_SUBJECT)
        guard let _ = subNode else {
            throw DIDError.malformedCredential("missing credential subject.")
        }
        let subject = try VerifiableCredentialSubject.fromJson(subNode!, ref)

        subNode = node.get(forKey: Constants.PROOF)
        guard let _ = subNode else {
            throw DIDError.malformedCredential("missing credential proof")
        }

        options = JsonSerializer.Options()
            .withOptional()
            .withHint("credential issuer")
            .withError(error)
        if ref != nil {
          options = options.withRef(ref)
        }
        var issuer = try? serializer.getDID(Constants.ISSUER, options)
        options = JsonSerializer.Options()
            .withHint("credential issuanceDate")
            .withError(error)
        let issuanceDate = try serializer.getDate(Constants.ISSUANCE_DATE, options)

        if issuer == nil {
            issuer = subject.did
        }
        let proof = try VerifiableCredentialProof.fromJson(subNode!, issuer)

        setIssuer(issuer!)
        setIssuanceDate(issuanceDate)
        setExpirationDate(expirationDate)
        setSubject(subject)
        setId(id!)
        setProof(proof)

        guard let _ = getIssuer() else {
            setIssuer(self.subject.did)
            return
        }
    }

    class func fromJson(_ node: JsonNode, _ ref: DID?) throws -> VerifiableCredential {
        let credential = VerifiableCredential()
        try credential.parse(node, ref)
        return credential
    }

    /// Convert data to VerifiableCredential
    /// - Parameter json: data in data format
    /// - Throws: An error is thrown when the conversion fails
    /// - Returns: VerifiableCredential
    public class func fromJson(_ json: Data) throws -> VerifiableCredential {
        guard !json.isEmpty else {
            throw DIDError.illegalArgument("json is empty.")
        }

        let data: [String: Any]?
        do {
            data = try JSONSerialization.jsonObject(with: json, options: []) as? [String: Any]
        } catch {
            throw DIDError.didResolveError("Parse resolve result error")
        }
        guard let _  = data else {
            throw DIDError.didResolveError("Parse resolve result error")
        }
        return try fromJson(JsonNode(data!), nil)
    }

    /// Convert string to VerifiableCredential
    /// - Parameter json: Data in string format
    /// - Throws: An error is thrown when the conversion fails
    /// - Returns: VerifiableCredential
    public class func fromJson(_ json: String) throws -> VerifiableCredential {
        return try fromJson(json.data(using: .utf8)!)
    }

    /// Convert array to VerifiableCredential
    /// - Parameter json: Data in array format
    /// - Throws: An error is thrown when the conversion fails
    /// - Returns: VerifiableCredential
    public class func fromJson(_ json: [String: Any]) throws -> VerifiableCredential {
        return try fromJson(JsonNode(json), nil)
    }

    func toJson(_ generator: JsonGenerator, _ ref: DID?, _ normalized: Bool) {
        toJson(generator, ref, normalized, false)
    }

    func toJson(_ generator: JsonGenerator, _ normalized: Bool) {
        toJson(generator, nil, normalized)
    }

    /*
    * Normalized serialization order:
    *
    * - id
    * - type ordered names array(case insensitive/ascending)
    * - issuer
    * - issuanceDate
    * - expirationDate
    * + credentialSubject
    *   - id
    *   - properties ordered by name(case insensitive/ascending)
    * + proof
    *   - type
    *   - method
    *   - signature
    */
    func toJson(_ generator: JsonGenerator, _ ref: DID?, _ normalized: Bool, _ forSign: Bool) {
        generator.writeStartObject()

        // id
        generator.writeFieldName(Constants.ID)
        generator.writeString(IDGetter(getId(), ref).value(normalized))

        // type
        generator.writeFieldName(Constants.TYPE)
        _types.sort { (a, b) -> Bool in
            let compareResult = a.compare(b)
            return compareResult == ComparisonResult.orderedAscending
        }
        generator.writeStartArray()
        for type in getTypes() {
            generator.writeString(type)
        }
        generator.writeEndArray()

        // issuer
        if normalized || issuer != subject.did {
            generator.writeStringField(Constants.ISSUER, issuer.toString())
        }

        // issuanceDate
        generator.writeFieldName(Constants.ISSUANCE_DATE)
        generator.writeString(DateFormatter.convertToUTCStringFromDate(issuanceDate))

        // expirationDate
        if let _ = getExpirationDate() {
            generator.writeFieldName(Constants.EXPIRATION_DATE)
            generator.writeString(DateFormatter.convertToUTCStringFromDate(expirationDate))
        }

        // credenitalSubject
        generator.writeFieldName(Constants.CREDENTIAL_SUBJECT)
        subject.toJson(generator, ref, normalized)

        // proof
        if !forSign {
            generator.writeFieldName(Constants.PROOF)
            proof.toJson(generator, issuer, normalized)
        }

        generator.writeEndObject()
    }

    func toJson(_ normalized: Bool, _ forSign: Bool) -> String {
        let generator = JsonGenerator()
        toJson(generator, nil, normalized, forSign)
        return generator.toString()
    }
}

extension VerifiableCredential: CustomStringConvertible {
    func toString(_ normalized: Bool) -> String {
        return toJson(normalized, false)
    }

    func toString() -> String {
        return toString(false)
    }

    public var description: String {
        return toString()
    }
}
